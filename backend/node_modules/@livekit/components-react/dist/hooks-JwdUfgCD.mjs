import * as r from "react";
import { u as k, r as x, a as J, b as H, c as w, d as j, e as X, f as A, g as Y, h as K, i as R, j as Z, k as ee, m as te, G as ne, n as se, o as ae, p as F, q as re, t as ce, v as _, w as W, x as Q, y as oe, l as T, z as ie, A as ue, B as N, C as de, D as le, E as fe, F as pe, H as be, I as me, J as ge, K as Se, M as B, N as ve, O as he, P as Me, Q as ye, S as Pe, T as ke, U as Ee, V as Te, W as $, X as we, Y as Ae, Z as Ce, _ as Ie, $ as Oe, a0 as De, a1 as Le, a2 as Re, a3 as Fe, a4 as Ne, a5 as Ve, a6 as Be, a7 as L, a8 as ze } from "./contexts-B7YgC7ji.mjs";
import { m as E } from "./room-BBI9Ul2f.mjs";
import { ConnectionQuality as Ue, ConnectionState as I, LocalTrackPublication as qe, facingModeFromLocalTrack as Je, Room as _e, Track as y, createAudioAnalyser as V, ParticipantKind as We } from "livekit-client";
const Qe = (e) => {
  const n = r.useRef(e);
  return r.useEffect(() => {
    n.current = e;
  }), n;
};
function $e(e, n) {
  const t = xe(), a = Qe(n);
  return r.useLayoutEffect(() => {
    let s = !1;
    const c = e.current;
    if (!c) return;
    function o(u, i) {
      s || a.current(u, i);
    }
    return t == null || t.subscribe(c, o), () => {
      s = !0, t == null || t.unsubscribe(c, o);
    };
  }, [e.current, t, a]), t == null ? void 0 : t.observer;
}
function Ge() {
  let e = !1, n = [];
  const t = /* @__PURE__ */ new Map();
  if (typeof window > "u")
    return;
  const a = new ResizeObserver((s, c) => {
    n = n.concat(s), e || window.requestAnimationFrame(() => {
      const o = /* @__PURE__ */ new Set();
      for (let u = 0; u < n.length; u++) {
        if (o.has(n[u].target)) continue;
        o.add(n[u].target);
        const i = t.get(n[u].target);
        i == null || i.forEach((d) => d(n[u], c));
      }
      n = [], e = !1;
    }), e = !0;
  });
  return {
    observer: a,
    subscribe(s, c) {
      a.observe(s);
      const o = t.get(s) ?? [];
      o.push(c), t.set(s, o);
    },
    unsubscribe(s, c) {
      const o = t.get(s) ?? [];
      if (o.length === 1) {
        a.unobserve(s), t.delete(s);
        return;
      }
      const u = o.indexOf(c);
      u !== -1 && o.splice(u, 1), t.set(s, o);
    }
  };
}
let D;
const xe = () => D || (D = Ge()), He = (e) => {
  const [n, t] = r.useState({ width: 0, height: 0 });
  r.useLayoutEffect(() => {
    if (e.current) {
      const { width: s, height: c } = e.current.getBoundingClientRect();
      t({ width: s, height: c });
    }
  }, [e.current]);
  const a = r.useCallback(
    (s) => t(s.contentRect),
    []
  );
  return $e(e, a), n;
};
function b(e, n, t = !0) {
  const [a, s] = r.useState(n);
  return r.useEffect(() => {
    if (t && s(n), typeof window > "u" || !e) return;
    const c = e.subscribe(s);
    return () => c.unsubscribe();
  }, [e, t]), a;
}
function gt(e) {
  const n = (c) => typeof window < "u" ? window.matchMedia(c).matches : !1, [t, a] = r.useState(n(e));
  function s() {
    a(n(e));
  }
  return r.useEffect(() => {
    const c = window.matchMedia(e);
    return s(), c.addListener ? c.addListener(s) : c.addEventListener("change", s), () => {
      c.removeListener ? c.removeListener(s) : c.removeEventListener("change", s);
    };
  }, [e]), t;
}
function St(e) {
  const n = k(e), t = r.useCallback(async () => {
    await n.startAudio();
  }, [n]), a = r.useMemo(
    () => x(n),
    [n]
  ), { canPlayAudio: s } = b(a, {
    canPlayAudio: n.canPlaybackAudio
  });
  return { canPlayAudio: s, startAudio: t };
}
function vt(e) {
  const { state: n, dispatch: t } = J().pin;
  return { buttonProps: r.useMemo(() => {
    const { className: s } = H();
    return E(e, {
      className: s,
      disabled: !(n != null && n.length),
      onClick: () => {
        t && t({ msg: "clear_pin" });
      }
    });
  }, [e, t, n]) };
}
function ht(e = {}) {
  const n = w(e.participant), { className: t, connectionQualityObserver: a } = r.useMemo(
    () => j(n),
    [n]
  ), s = b(a, Ue.Unknown);
  return { className: t, quality: s };
}
function O(e) {
  const n = k(e), t = r.useMemo(() => X(n), [n]);
  return b(t, n.state);
}
function Mt(e, n) {
  const t = typeof e == "function" ? e : n, a = typeof e == "string" ? e : void 0, s = A(), { send: c, messageObservable: o, isSendingObservable: u } = r.useMemo(
    () => Y(s, a, t),
    [s, a, t]
  ), i = b(o, void 0), d = b(u, !1);
  return {
    message: i,
    send: c,
    isSending: d
  };
}
function yt(e) {
  const n = A(), t = O(n);
  return { buttonProps: r.useMemo(() => {
    const { className: s, disconnect: c } = K(n);
    return E(e, {
      className: s,
      onClick: () => c(e.stopTracks ?? !0),
      disabled: t === I.Disconnected
    });
  }, [n, e, t]) };
}
function je(e) {
  if (e.publication instanceof qe) {
    const n = e.publication.track;
    if (n) {
      const { facingMode: t } = Je(n);
      return t;
    }
  }
  return "undefined";
}
function Pt({ trackRef: e, props: n }) {
  const t = R(e), a = Z(), { className: s } = r.useMemo(() => ee(), []), c = r.useMemo(() => te(t, a == null ? void 0 : a.pin.state), [t, a == null ? void 0 : a.pin.state]);
  return { mergedProps: r.useMemo(
    () => E(n, {
      className: s,
      onClick: (u) => {
        var i, d, l, f, p;
        (i = n.onClick) == null || i.call(n, u), c ? (l = a == null ? void 0 : (d = a.pin).dispatch) == null || l.call(d, {
          msg: "clear_pin"
        }) : (p = a == null ? void 0 : (f = a.pin).dispatch) == null || p.call(f, {
          msg: "set_pin",
          trackReference: t
        });
      }
    }),
    [n, s, t, c, a == null ? void 0 : a.pin]
  ), inFocus: c };
}
function kt(e, n, t = {}) {
  const a = t.gridLayouts ?? ne, { width: s, height: c } = He(e), o = se(a, n, s, c);
  return r.useEffect(() => {
    e.current && o && (e.current.style.setProperty("--lk-col-count", o == null ? void 0 : o.columns.toString()), e.current.style.setProperty("--lk-row-count", o == null ? void 0 : o.rows.toString()));
  }, [e, o]), {
    layout: o,
    containerWidth: s,
    containerHeight: c
  };
}
function z(e, n = {}) {
  var u, i;
  const t = typeof e == "string" ? n.participant : e.participant, a = w(t), s = typeof e == "string" ? { participant: a, source: e } : e, [c, o] = r.useState(
    !!((u = s.publication) != null && u.isMuted || (i = a.getTrackPublication(s.source)) != null && i.isMuted)
  );
  return r.useEffect(() => {
    const d = ae(s).subscribe(o);
    return () => d.unsubscribe();
  }, [F(s)]), c;
}
function Xe(e) {
  const n = w(e), t = r.useMemo(() => re(n), [n]);
  return b(t, n.isSpeaking);
}
function Ye(e = {}) {
  const n = k(e.room), [t, a] = r.useState(n.localParticipant), [s, c] = r.useState(
    t.isMicrophoneEnabled
  ), [o, u] = r.useState(
    t.isMicrophoneEnabled
  ), [i, d] = r.useState(
    t.lastMicrophoneError
  ), [l, f] = r.useState(t.lastCameraError), [p, g] = r.useState(
    t.isMicrophoneEnabled
  ), [S, m] = r.useState(
    void 0
  ), [M, v] = r.useState(void 0), P = (h) => {
    u(h.isCameraEnabled), c(h.isMicrophoneEnabled), g(h.isScreenShareEnabled), v(h.cameraTrack), m(h.microphoneTrack), d(h.participant.lastMicrophoneError), f(h.participant.lastCameraError), a(h.participant);
  };
  return r.useEffect(() => {
    const h = ce(n.localParticipant).subscribe(P);
    return () => h.unsubscribe();
  }, [n]), {
    isMicrophoneEnabled: s,
    isScreenShareEnabled: p,
    isCameraEnabled: o,
    microphoneTrack: S,
    cameraTrack: M,
    lastMicrophoneError: i,
    lastCameraError: l,
    localParticipant: t
  };
}
function Et() {
  const e = A(), n = r.useMemo(
    () => _(e.localParticipant),
    [e]
  );
  return b(n, e.localParticipant.permissions);
}
function Tt({
  kind: e,
  room: n,
  track: t,
  requestPermissions: a,
  onError: s
}) {
  const c = W(), o = r.useMemo(() => n ?? c ?? new _e(), [n, c]), u = r.useMemo(
    () => Q(e, s, a),
    [e, a, s]
  ), i = b(u, []), [d, l] = r.useState(
    (o == null ? void 0 : o.getActiveDevice(e)) ?? "default"
  ), { className: f, activeDeviceObservable: p, setActiveMediaDevice: g } = r.useMemo(
    () => oe(e, o),
    [e, o, t]
  );
  return r.useEffect(() => {
    const S = p.subscribe((m) => {
      m && (T.info("setCurrentDeviceId", m), l(m));
    });
    return () => {
      S == null || S.unsubscribe();
    };
  }, [p]), { devices: i, className: f, activeDeviceId: d, setActiveMediaDevice: g };
}
function wt({
  kind: e,
  onError: n
}) {
  const t = r.useMemo(
    () => Q(e, n),
    [e, n]
  );
  return b(t, []);
}
function Ke(e, n, t = {}) {
  const a = r.useRef([]), s = r.useRef(-1), c = n !== s.current, o = typeof t.customSortFunction == "function" ? t.customSortFunction(e) : ie(e);
  let u = [...o];
  if (c === !1)
    try {
      u = ue(a.current, o, n);
    } catch (i) {
      T.error("Error while running updatePages(): ", i);
    }
  return c ? a.current = o : a.current = u, s.current = n, u;
}
function At(e, n) {
  const [t, a] = r.useState(1), s = Math.max(Math.ceil(n.length / e), 1);
  t > s && a(s);
  const c = t * e, o = c - e, u = (f) => {
    a((p) => f === "next" ? p === s ? p : p + 1 : p === 1 ? p : p - 1);
  }, i = (f) => {
    f > s ? a(s) : f < 1 ? a(1) : a(f);
  }, l = Ke(n, e).slice(o, c);
  return {
    totalPageCount: s,
    nextPage: () => u("next"),
    prevPage: () => u("previous"),
    setPage: i,
    firstItemIndex: o,
    lastItemIndex: c,
    tracks: l,
    currentPage: t
  };
}
function Ct(e = {}) {
  let n = N();
  e.participant && (n = e.participant);
  const t = r.useMemo(() => de(n), [n]), { identity: a, name: s, metadata: c } = b(t, {
    name: n == null ? void 0 : n.name,
    identity: n == null ? void 0 : n.identity,
    metadata: n == null ? void 0 : n.metadata
  });
  return { identity: a, name: s, metadata: c };
}
function It(e = {}) {
  const n = w(e.participant), t = r.useMemo(() => _(n), [n]);
  return b(t, n.permissions);
}
function Ot({
  trackRef: e,
  onParticipantClick: n,
  disableSpeakingIndicator: t,
  htmlProps: a
}) {
  const s = R(e), c = r.useMemo(() => {
    const { className: p } = le();
    return E(a, {
      className: p,
      onClick: (g) => {
        var S;
        if ((S = a.onClick) == null || S.call(a, g), typeof n == "function") {
          const m = s.publication ?? s.participant.getTrackPublication(s.source);
          n({ participant: s.participant, track: m });
        }
      }
    });
  }, [
    a,
    n,
    s.publication,
    s.source,
    s.participant
  ]), o = s.participant.getTrackPublication(y.Source.Microphone), u = r.useMemo(() => ({
    participant: s.participant,
    source: y.Source.Microphone,
    publication: o
  }), [o, s.participant]), i = z(s), d = z(u), l = Xe(s.participant), f = je(s);
  return {
    elementProps: {
      "data-lk-audio-muted": d,
      "data-lk-video-muted": i,
      "data-lk-speaking": t === !0 ? !1 : l,
      "data-lk-local-participant": s.participant.isLocal,
      "data-lk-source": s.source,
      "data-lk-facing-mode": f,
      ...c
    }
  };
}
function G(e = {}) {
  const n = k(e.room), [t, a] = r.useState([]);
  return r.useEffect(() => {
    const s = fe(n, {
      additionalRoomEvents: e.updateOnlyOn
    }).subscribe(a);
    return () => s.unsubscribe();
  }, [n, JSON.stringify(e.updateOnlyOn)]), t;
}
function Dt(e = {}) {
  const n = G(e), { localParticipant: t } = Ye(e);
  return r.useMemo(
    () => [t, ...n],
    [t, n]
  );
}
function Lt(e) {
  return e = pe(e), r.useMemo(() => (e == null ? void 0 : e.pin.state) !== void 0 && e.pin.state.length >= 1 ? e.pin.state : [], [e.pin.state]);
}
function Rt(e, n = {}) {
  const t = A(), [a] = r.useState(n.updateOnlyOn), s = r.useMemo(() => typeof e == "string" ? be(t, e, {
    additionalEvents: a
  }) : me(t, e, {
    additionalEvents: a
  }), [t, JSON.stringify(e), a]), [c, o] = r.useState({
    p: void 0
  });
  return r.useEffect(() => {
    const u = s.subscribe((i) => o({ p: i }));
    return () => u.unsubscribe();
  }, [s]), c.p;
}
function Ft(e = {}) {
  const n = k(e.room), t = r.useMemo(() => ge(n), [n]), { name: a, metadata: s } = b(t, {
    name: n.name,
    metadata: n.metadata
  });
  return { name: a, metadata: s };
}
function Ze() {
  const e = A(), n = r.useMemo(() => Se(e), [e]);
  return b(n, e.activeSpeakers);
}
function Nt(e) {
  const [n, t] = r.useState(
    B(e)
  ), a = Ze();
  return r.useEffect(() => {
    t(B(e));
  }, [a, e]), n;
}
function Vt({ room: e, props: n }) {
  const t = k(e), { className: a, roomAudioPlaybackAllowedObservable: s, handleStartAudioPlayback: c } = r.useMemo(
    () => ve(),
    []
  ), o = r.useMemo(
    () => s(t),
    [t, s]
  ), { canPlayAudio: u } = b(o, {
    canPlayAudio: t.canPlaybackAudio
  });
  return { mergedProps: r.useMemo(
    () => E(n, {
      className: a,
      onClick: () => {
        c(t);
      },
      style: { display: u ? "none" : "block" }
    }),
    [n, a, u, c, t]
  ), canPlayAudio: u };
}
function Bt({ room: e, props: n }) {
  const t = k(e), { className: a, roomVideoPlaybackAllowedObservable: s, handleStartVideoPlayback: c } = r.useMemo(
    () => he(),
    []
  ), o = r.useMemo(
    () => s(t),
    [t, s]
  ), { canPlayVideo: u } = b(o, {
    canPlayVideo: t.canPlaybackVideo
  });
  return { mergedProps: r.useMemo(
    () => E(n, {
      className: a,
      onClick: () => {
        c(t);
      },
      style: { display: u ? "none" : "block" }
    }),
    [n, a, u, c, t]
  ), canPlayVideo: u };
}
function zt(e, n = {}) {
  const t = r.useRef(null), a = r.useRef(null), s = n.minSwipeDistance ?? 50, c = (i) => {
    a.current = null, t.current = i.targetTouches[0].clientX;
  }, o = (i) => {
    a.current = i.targetTouches[0].clientX;
  }, u = r.useCallback(() => {
    if (!t.current || !a.current)
      return;
    const i = t.current - a.current, d = i > s, l = i < -s;
    d && n.onLeftSwipe && n.onLeftSwipe(), l && n.onRightSwipe && n.onRightSwipe();
  }, [s, n]);
  r.useEffect(() => {
    const i = e.current;
    return i && (i.addEventListener("touchstart", c, { passive: !0 }), i.addEventListener("touchmove", o, { passive: !0 }), i.addEventListener("touchend", u, { passive: !0 })), () => {
      i && (i.removeEventListener("touchstart", c), i.removeEventListener("touchmove", o), i.removeEventListener("touchend", u));
    };
  }, [e, u]);
}
function Ut({ props: e }) {
  const { dispatch: n, state: t } = J().widget, { className: a } = r.useMemo(() => Me(), []);
  return { mergedProps: r.useMemo(() => E(e, {
    className: a,
    onClick: () => {
      n && n({ msg: "toggle_chat" });
    },
    "aria-pressed": t != null && t.showChat ? "true" : "false",
    "data-lk-unread-msgs": t ? t.unreadMessages < 10 ? t.unreadMessages.toFixed(0) : "9+" : "0"
  }), [e, a, n, t]) };
}
function qt(e, n, t = {}) {
  const [a, s] = r.useState(void 0);
  return r.useEffect(() => {
    var o;
    if (e === void 0)
      throw Error("token endpoint needs to be defined");
    if (((o = t.userInfo) == null ? void 0 : o.identity) === void 0)
      return;
    (async () => {
      T.debug("fetching token");
      const u = new URLSearchParams({ ...t.userInfo, roomName: n }), i = await fetch(`${e}?${u.toString()}`);
      if (!i.ok) {
        T.error(
          `Could not fetch token. Server responded with status ${i.status}: ${i.statusText}`
        );
        return;
      }
      const { accessToken: d } = await i.json();
      s(d);
    })();
  }, [e, n, JSON.stringify(t)]), a;
}
function Jt(e) {
  var c, o;
  const n = R(e), { className: t, mediaMutedObserver: a } = r.useMemo(
    () => ye(n),
    [F(n)]
  );
  return { isMuted: b(
    a,
    !!((c = n.publication) != null && c.isMuted || (o = n.participant.getTrackPublication(n.source)) != null && o.isMuted)
  ), className: t };
}
function _t({
  source: e,
  onChange: n,
  initialState: t,
  captureOptions: a,
  publishOptions: s,
  onDeviceError: c,
  ...o
}) {
  var P;
  const u = W(), i = (P = u == null ? void 0 : u.localParticipant) == null ? void 0 : P.getTrackPublication(e), d = r.useRef(!1), { toggle: l, className: f, pendingObserver: p, enabledObserver: g } = r.useMemo(
    () => u ? Pe(e, u, a, s, c) : ke(),
    [u, e, JSON.stringify(a), s]
  ), S = b(p, !1), m = b(g, t ?? !!(i != null && i.isEnabled));
  r.useEffect(() => {
    n == null || n(m, d.current), d.current = !1;
  }, [m, n]), r.useEffect(() => {
    t !== void 0 && (T.debug("forcing initial toggle state", e, t), l(t));
  }, []);
  const M = r.useMemo(() => E(o, { className: f }), [o, f]), v = r.useCallback(
    (h) => {
      var C;
      d.current = !0, l().catch(() => d.current = !1), (C = o.onClick) == null || C.call(o, h);
    },
    [o, l]
  );
  return {
    toggle: l,
    enabled: m,
    pending: S,
    track: i,
    buttonProps: {
      ...M,
      "aria-pressed": m,
      "data-lk-source": e,
      "data-lk-enabled": m,
      disabled: S,
      onClick: v
    }
  };
}
function Wt(e = [
  y.Source.Camera,
  y.Source.Microphone,
  y.Source.ScreenShare,
  y.Source.ScreenShareAudio,
  y.Source.Unknown
], n = {}) {
  const t = k(n.room), [a, s] = r.useState([]), [c, o] = r.useState([]), u = r.useMemo(() => e.map((d) => Ee(d) ? d.source : d), [JSON.stringify(e)]);
  return r.useEffect(() => {
    const d = Te(t, u, {
      additionalRoomEvents: n.updateOnlyOn,
      onlySubscribed: n.onlySubscribed
    }).subscribe(({ trackReferences: l, participants: f }) => {
      T.debug("setting track bundles", l, f), s(l), o(f);
    });
    return () => d.unsubscribe();
  }, [
    t,
    JSON.stringify(n.onlySubscribed),
    JSON.stringify(n.updateOnlyOn),
    JSON.stringify(e)
  ]), r.useMemo(() => {
    if ($(e)) {
      const d = tt(e, c), l = Array.from(a);
      return c.forEach((f) => {
        d.has(f.identity) && (d.get(f.identity) ?? []).forEach((g) => {
          if (a.find(
            ({ participant: m, publication: M }) => f.identity === m.identity && M.source === g
          ))
            return;
          T.debug(
            `Add ${g} placeholder for participant ${f.identity}.`
          );
          const S = {
            participant: f,
            source: g
          };
          l.push(S);
        });
      }), l;
    } else
      return a;
  }, [a, c, e]);
}
function et(e, n) {
  const t = new Set(e);
  for (const a of n)
    t.delete(a);
  return t;
}
function tt(e, n) {
  const t = /* @__PURE__ */ new Map();
  if ($(e)) {
    const a = e.filter((s) => s.withPlaceholder).map((s) => s.source);
    n.forEach((s) => {
      const c = s.getTrackPublications().map((u) => {
        var i;
        return (i = u.track) == null ? void 0 : i.source;
      }).filter((u) => u !== void 0), o = Array.from(
        et(new Set(a), new Set(c))
      );
      o.length > 0 && t.set(s.identity, o);
    });
  }
  return t;
}
function nt(e) {
  const [n, t] = r.useState(we(e)), { trackObserver: a } = r.useMemo(() => Ae(e), [e.participant.sid ?? e.participant.identity, e.source]);
  return r.useEffect(() => {
    const s = a.subscribe((c) => {
      t(c);
    });
    return () => s == null ? void 0 : s.unsubscribe();
  }, [a]), {
    participant: e.participant,
    source: e.source ?? y.Source.Unknown,
    publication: n
  };
}
function Qt(e, n) {
  const t = w(n);
  return nt({ name: e, participant: t });
}
function $t(e) {
  const n = A(), t = O(n), a = r.useMemo(
    () => t === I.Disconnected,
    [t]
  ), s = r.useMemo(
    () => Ce(n, e),
    [n, e, a]
  ), c = b(s.isSendingObservable, !1), o = b(s.messageObservable, []);
  return { send: s.send, update: s.update, chatMessages: o, isSending: c };
}
function Gt(e = {}) {
  const [n, t] = r.useState(
    Ie(e.defaults, e.preventLoad ?? !1)
  ), a = r.useCallback((i) => {
    t((d) => ({ ...d, audioEnabled: i }));
  }, []), s = r.useCallback((i) => {
    t((d) => ({ ...d, videoEnabled: i }));
  }, []), c = r.useCallback((i) => {
    t((d) => ({ ...d, audioDeviceId: i }));
  }, []), o = r.useCallback((i) => {
    t((d) => ({ ...d, videoDeviceId: i }));
  }, []), u = r.useCallback((i) => {
    t((d) => ({ ...d, username: i }));
  }, []);
  return r.useEffect(() => {
    Oe(n, e.preventSave ?? !1);
  }, [n, e.preventSave]), {
    userChoices: n,
    saveAudioInputEnabled: a,
    saveVideoInputEnabled: s,
    saveAudioInputDeviceId: c,
    saveVideoInputDeviceId: o,
    saveUsername: u
  };
}
function xt(e, n = {}) {
  const t = w(e), a = k(n.room), s = r.useMemo(() => De(a, t), [a, t]);
  return b(
    s,
    t.isLocal ? t.isE2EEEnabled : !!(t != null && t.isEncrypted)
  );
}
function Ht(e, n = { fftSize: 32, smoothingTimeConstant: 0 }) {
  const t = Le(e) ? e.publication.track : e, [a, s] = r.useState(0);
  return r.useEffect(() => {
    if (!t || !t.mediaStream)
      return;
    const { cleanup: c, analyser: o } = V(t, n), u = o.frequencyBinCount, i = new Uint8Array(u), l = setInterval(() => {
      o.getByteFrequencyData(i);
      let f = 0;
      for (let p = 0; p < i.length; p++) {
        const g = i[p];
        f += g * g;
      }
      s(Math.sqrt(f / i.length) / 255);
    }, 1e3 / 30);
    return () => {
      c(), clearInterval(l);
    };
  }, [t, t == null ? void 0 : t.mediaStream, JSON.stringify(n)]), a;
}
const st = (e) => {
  const n = (t) => {
    let c = 1 - Math.max(-100, Math.min(-10, t)) * -1 / 100;
    return c = Math.sqrt(c), c;
  };
  return e.map((t) => t === -1 / 0 ? 0 : n(t));
}, at = {
  bands: 5,
  loPass: 100,
  hiPass: 600,
  updateInterval: 32,
  analyserOptions: { fftSize: 2048 }
};
function jt(e, n = {}) {
  var o;
  const t = e instanceof y ? e : (o = e == null ? void 0 : e.publication) == null ? void 0 : o.track, a = { ...at, ...n }, [s, c] = r.useState(
    new Array(a.bands).fill(0)
  );
  return r.useEffect(() => {
    if (!t || !(t != null && t.mediaStream))
      return;
    const { analyser: u, cleanup: i } = V(t, a.analyserOptions), d = u.frequencyBinCount, l = new Float32Array(d), p = setInterval(() => {
      u.getFloatFrequencyData(l);
      let g = new Float32Array(l.length);
      for (let v = 0; v < l.length; v++)
        g[v] = l[v];
      g = g.slice(n.loPass, n.hiPass);
      const S = st(g), m = Math.ceil(S.length / a.bands), M = [];
      for (let v = 0; v < a.bands; v++) {
        const P = S.slice(v * m, (v + 1) * m).reduce((h, C) => h += C, 0);
        M.push(P / m);
      }
      c(M);
    }, a.updateInterval);
    return () => {
      i(), clearInterval(p);
    };
  }, [t, t == null ? void 0 : t.mediaStream, JSON.stringify(n)]), s;
}
const rt = {
  barCount: 120,
  volMultiplier: 5,
  updateInterval: 20
};
function Xt(e, n = {}) {
  var l;
  const t = e instanceof y ? e : (l = e == null ? void 0 : e.publication) == null ? void 0 : l.track, a = { ...rt, ...n }, s = r.useRef(new Float32Array()), c = r.useRef(performance.now()), o = r.useRef(0), [u, i] = r.useState([]), d = r.useCallback((f) => {
    i(
      Array.from(
        ot(f, a.barCount).map((p) => Math.sqrt(p) * a.volMultiplier)
        // wave.slice(0, opts.barCount).map((v) => sigmoid(v * opts.volMultiplier, 0.08, 0.2)),
      )
    );
  }, []);
  return r.useEffect(() => {
    if (!t || !(t != null && t.mediaStream))
      return;
    const { analyser: f, cleanup: p } = V(t, {
      fftSize: U(a.barCount)
    }), g = U(a.barCount), S = new Float32Array(g), m = () => {
      if (M = requestAnimationFrame(m), f.getFloatTimeDomainData(S), s.current.map((v, P) => v + S[P]), o.current += 1, performance.now() - c.current >= a.updateInterval) {
        const v = S.map((P) => P / o.current);
        d(v), c.current = performance.now(), o.current = 0;
      }
    };
    let M = requestAnimationFrame(m);
    return () => {
      p(), cancelAnimationFrame(M);
    };
  }, [t, t == null ? void 0 : t.mediaStream, JSON.stringify(n), d]), {
    bars: u
  };
}
function U(e) {
  return e < 32 ? 32 : ct(e);
}
function ct(e) {
  let n = 2;
  for (; e >>= 1; )
    n <<= 1;
  return n;
}
function ot(e, n) {
  const t = Math.floor(e.length / n), a = new Float32Array(n);
  for (let s = 0; s < n; s++) {
    const c = t * s;
    let o = 0;
    for (let u = 0; u < t; u++)
      o = o + Math.abs(e[c + u]);
    a[s] = o / t;
  }
  return a;
}
function it(e, n) {
  const t = A(), a = N(), s = n ? t.getParticipantByIdentity(n) : a, c = r.useMemo(
    () => s ? Re(s, { sources: e }) : void 0,
    [s == null ? void 0 : s.sid, s == null ? void 0 : s.identity, JSON.stringify(e)]
  );
  return b(c, []);
}
function ut(e) {
  var t, a, s;
  const n = r.useMemo(
    () => {
      var c;
      return (c = e == null ? void 0 : e.publication) != null && c.track ? Fe(e == null ? void 0 : e.publication.track) : void 0;
    },
    [(t = e == null ? void 0 : e.publication) == null ? void 0 : t.track]
  );
  return b(n, {
    timestamp: Date.now(),
    rtpTimestamp: (s = (a = e == null ? void 0 : e.publication) == null ? void 0 : a.track) == null ? void 0 : s.rtpTimestamp
  });
}
const dt = {
  bufferSize: 100
  // maxAge: 2_000,
};
function lt(e, n) {
  const t = { ...dt, ...n }, [a, s] = r.useState([]), c = ut(e), o = (u) => {
    var i;
    (i = t.onTranscription) == null || i.call(t, u), s(
      (d) => Ve(
        d,
        // when first receiving a segment, add the current media timestamp to it
        u.map((l) => Be(l, c)),
        t.bufferSize
      )
    );
  };
  return r.useEffect(() => {
    if (!(e != null && e.publication))
      return;
    const u = Ne(e.publication).subscribe((i) => {
      o(...i);
    });
    return () => {
      u.unsubscribe();
    };
  }, [e && F(e), o]), { segments: a };
}
function ft(e = {}) {
  const n = N(), t = e.participant ?? n, a = r.useMemo(
    // weird typescript constraint
    () => t ? L(t) : L(t),
    [t]
  );
  return b(a, {
    attributes: t == null ? void 0 : t.attributes
  });
}
function Yt(e, n = {}) {
  const t = w(n.participant), [a, s] = r.useState(t.attributes[e]);
  return r.useEffect(() => {
    if (!t)
      return;
    const c = L(t).subscribe((o) => {
      o.changed[e] !== void 0 && s(o.attributes[e]);
    });
    return () => {
      c.unsubscribe();
    };
  }, [t, e]), a;
}
const q = "lk.agent.state";
function Kt() {
  const e = G().find((o) => o.kind === We.AGENT), n = it([y.Source.Microphone], e == null ? void 0 : e.identity)[0], { segments: t } = lt(n), a = O(), { attributes: s } = ft({ participant: e }), c = r.useMemo(() => a === I.Disconnected ? "disconnected" : a === I.Connecting || !e || !(s != null && s[q]) ? "connecting" : s[q], [s, e, a]);
  return {
    agent: e,
    state: c,
    audioTrack: n,
    agentTranscriptions: t,
    agentAttributes: s
  };
}
function Zt(e) {
  const n = k(e), t = O(n), a = r.useMemo(() => ze(n), [n, t]);
  return b(a, n.isRecording);
}
export {
  Et as A,
  Lt as B,
  Ye as C,
  St as D,
  Mt as E,
  je as F,
  z as G,
  Xe as H,
  Ct as I,
  It as J,
  Dt as K,
  Rt as L,
  G as M,
  Nt as N,
  Ze as O,
  qt as P,
  Qt as Q,
  Ht as R,
  Xt as S,
  it as T,
  lt as U,
  Kt as V,
  ft as W,
  Yt as X,
  Zt as Y,
  O as a,
  Ut as b,
  yt as c,
  Pt as d,
  Tt as e,
  Vt as f,
  Bt as g,
  _t as h,
  ht as i,
  b as j,
  Jt as k,
  Ot as l,
  xt as m,
  kt as n,
  At as o,
  zt as p,
  He as q,
  Ke as r,
  jt as s,
  Wt as t,
  vt as u,
  Ft as v,
  $t as w,
  wt as x,
  Gt as y,
  gt as z
};
//# sourceMappingURL=hooks-JwdUfgCD.mjs.map
